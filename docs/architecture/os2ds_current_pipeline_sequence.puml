@startuml
actor user

participant admin

database admin_db

participant checkup_collector as cc
participant status_collector as sc
participant explorer
participant worker
participant exporter

queue RabbitMq as mq

participant event_collector as ec
participant result_collector as rc
participant report

database report_db


=== Scanner Job startup == 

user -> admin : Start Scanner job
activate admin
        admin -> mq : os2ds_scan_specs(scan_spec)
        admin --> user : Scanner job started
deactivate admin

=== Exploration stage ==

loop os2ds_scan_specs is not empty
        explorer -> mq : consume(os2ds_scan_specs)
        activate explorer
                return scan_spec message
                
                explorer -> explorer : message_received_raw(body, channel, source_manager)
                activate explorer
                        alt successful conversion
                                explorer -> mq : os2ds_conversions(scan_spec, handle, progress)
                        else nested source
                                explorer -> mq : os2ds_scan_specs(scan_spec)
                        else failed conversion
                                explorer -> mq : os2ds_problems(problem_message)
                        end
                        explorer -> mq : os2ds_status(status_message)
                        
                deactivate explorer
        deactivate explorer
end

=== Worker stage ==

worker -> worker : message_received_raw(body, channel, source_manager)
activate worker
        alt processor 
                loop os2ds_conversions is not empty
                        worker -> mq : consume(os2ds_conversions)
                        mq -> worker : conversions_message
                        worker -> worker : processor_handler(conversions_message)
                        activate worker
                                alt conversion obtained representation
                                        worker -> mq : os2ds_representations(representations_message)
                                else conversion obtained nested source
                                        worker -> mq : os2ds_scan_specs(scan_spec_message)
                                else conversion failed
                                        worker -> mq : os2ds_problems(problem_message)
                                        worker -> mq : os2ds_checkups(problem_message)
                                end
                        deactivate worker
                end
        else explorer 
                loop os2ds_scan_specs is not empty
                        worker -> mq : consume(os2ds_scan_specs)
                        mq -> worker : scan_spec_message
                        worker -> worker : explorer_handler(scan_spec_message)
                        activate worker
                                alt exploration yielded handles
                                        worker -> mq : os2ds_conversions(conversions_message)
                                else exploration yielded independent sources
                                        worker -> mq : os2ds_scan_specs(scan_spec_message)
                                else exploration failed
                                        worker -> mq : os2ds_problems(problem_message)
                                end

                                worker -> mq : os2ds_status(status_message)
                        deactivate worker
                end
        else matcher
                loop os2ds_representations is not empty
                        worker -> mq : consume(os2ds_representations)
                        mq -> worker : representations_message
                        worker -> worker : match_handler(representations_message)
                        activate worker
                                alt matching without error
                                        alt conclusion
                                                worker -> mq : os2ds_matches(matches_message)
                                                worker -> mq : os2ds_checkups(matches_message)
                                        else needs conversion
                                                worker -> mq : os2ds_conversions(conversions_message)
                                        end
                                else matching error
                                        worker -> mq : os2ds_problems(problem_message)
                                        worker -> mq : os2ds_checkups(problem_message)
                                end
                        deactivate worker
                end
        else tagger
                loop os2ds_handles is not empty
                        worker -> mq : consume(os2ds_handles)
                        mq -> worker : handles_message
                        worker -> worker : tagger_handler(handles_message)
                        activate worker
                                alt metadata extraction successful
                                        worker -> mq : os2ds_metadata(metadata_message)
                                else metadata extraction failed
                                        worker -> mq : os2ds_problems(problem_message)
                                end
                        deactivate worker
                end
        end
        worker -> mq : os2ds_status(status_message)
deactivate worker

=== Exporter Stage ==

exporter -> exporter : message_received_raw(body, channel, source_manager)
activate exporter
        loop os2ds_matches & os2ds_metadata & os2ds_problems are not empty
                alt body is metadata_message
                        exporter -> exporter : MetadataMessage(body)
                else body is matches_message
                        exporter -> exporter : MatchesMessage(body)
                else body is problem_message
                        exporter -> exporter : ProblemMessage(body)
                end

                alt message is defined
                        exporter -> exporter : censor_outgoing_message(message) 
                        exporter -> mq : os2ds_results(result_body)
                end
        end
deactivate exporter

=== Collector Stages ==

== Checkup Collector ==

cc -> cc : checkup_message_received_raw(body)
activate cc
        alt body contains problem_message
               cc -> cc : ProblemMessage(body) 
        else body contains matches_message
               cc -> cc : MatchesMessage(body) 
        end

        alt scanner & scan_status exists
                cc -> admin_db : get(scanner)
                admin_db -> cc : scanner
                cc -> admin_db : get(scan_status)
                admin_db -> cc : scan_status
        else scanner does not exist
        else scan_status does not exist
                cc -> cc : CommandMessage(scan_tag)
                cc -> mq : broadcast(msg)
        end

        cc -> cc : update_scheduled_checkup(handle, matches, problem, scan_time, scanner)
        activate cc
                cc -> admin_db : select_for_update(ScheduledCheckup, scanner)
                admin_db -> cc : locked_qs

                alt locked_qs contains checkup object
                        alt message is matches_message
                                alt no matches
                                        alt rule is LastModifiedRule
                                                cc -> admin_db : locked_qs.update()
                                        else checkup no longer necessary
                                                cc -> admin_db : locked_qs.delete()
                                        end
                                else found matches
                                        cc -> admin_db : locked_qs.update()
                                end
                        else message is problem_message
                                alt object is missing
                                        cc -> admin_db : locked_qs.delete()
                                end
                        end
                else no existing checkup object
                        cc -> admin_db : update_or_create(ScheduledCheckup, handle, scanner)
                        alt message is problem_message
                                cc -> cc : create_usererrorlog(problem)
                        end
                end
        deactivate cc
deactivate cc

== Status Collector ==

sc -> sc : status_message_received_raw(body)
activate sc
        sc -> sc : StatusMessage(body)

        alt scanner exists
                sc -> admin_db : get(Scanner)
                admin_db -> sc : scanner
        else scanner does not exist
                sc -> sc : log()
        end

        sc -> admin_db : select_for_update(ScanStatus, scanner, body)
        admin_db -> sc : locked_qs

        alt message has object count
                sc -> admin_db : update(locked_qs, message, total_objects, total_sources)
        else message has object size and type
                sc -> admin_db : update(locked_qs, message, scanned_size, scanned_objects)
        end

        alt message has found matches
                sc -> admin_db : update(locked_qs, matches_found)
        end 

        alt locked_qs has scan_status
                alt should take snapshot
                        sc -> admin_db : create(ScanStatusSnapshot, scan_status, time_stamp, total_sources, explored_sources total_objects, scanned_objects, scanned_size)
                end

                alt scanner job is finished
                        sc -> sc : send_mail_upon_completion(scanner, scan_status)
                end
        end
deactivate sc

== Event Collector ==

ec -> ec : event_message_received_raw(body)
activate ec
        alt event processing successful
                alt event_type is bulk_event_create
                        loop models to create
                                ec -> report_db : create(model)
                        end
                else event_type is bulk_event_update
                        loop models to update
                                ec -> report_db : update(model)
                        end
                else event_type is bulk_event_delete
                        loop models to delete
                                ec -> report_db : delete(model)
                        end
                else event_type is bulk_event_purge
                        loop models to purge
                                ec -> report_db : delete_all(model)
                        end
                else event_type is clean_document_reports
                        ec -> ec : handle_clean_message(body)
                        activate ec
                                loop for each scanner and account
                                        ec -> report_db : filter(DocumentReport, account, scanner)
                                        report_db -> ec : related_reports
                                        ec -> report_db : delete(related_reports)
                                end
                        deactivate ec
                end
        else event processing failure
                ec -> ec : log()
        end
deactivate ec

== Result Collector ==

rc -> rc : result_message_received_raw(body)
activate rc
        alt queue is matches
                rc -> rc : handle_match_message(tag, body)
                activate rc
                        rc -> report_db : select_for_update(DocumentReport)
                        report_db -> rc : locked_qs
                        alt previous report has resolution status
                                rc -> report_db : update(DocumentReport)
                        end

                        alt new matches found
                                rc -> report_db : update_or_create(DocumentReport)
                        end
                deactivate rc
        else queue is problem
                rc -> rc : handle_problem_message(tag, body)
                activate rc
                        rc -> report_db : select_for_update(DocumentReport)
                        report_db -> rc : locked_qs
                        alt previous report contains deleted resource
                                rc -> report_db : update(DocumentReport)
                        else problem is still relevant
                                rc -> report_db : update_or_create(DocumentReport)
                        end
                deactivate rc
        else queue is metadata
                rc -> rc : handle_metadata_message(tag, body)
                activate rc
                        rc -> report_db : update_or_create(DocumentReport)
                        rc -> rc : create_aliases(document_report)
                deactivate rc
        end
deactivate rc

=== Scanner job complete ==

user -> report : Check for matches
activate report
        report -> report_db : get(DocumentReport) 
        report_db -> report : document_reports
        report -> user : present matches
deactivate report

@enduml
